#define _CRT_SRCURE_NO_WARNINGS 1
#include<stdio.h>
#include<stdlib.h>




void Print(int arr[],int length){
	for (int i = 0; i < length;i++){
		printf("%d ",arr[i]);
	}
	printf("\n");
}
//    bubble
void insert_sort(int arr[],int length){
	for (int i = 1; i < length;i++){
		if (arr[i] < arr[i-1]){
			int j = 0;
			int tmp = arr[i];
			for (j = i - 1; j >= 0 && arr[j] > tmp;j--){
				arr[j + 1] = arr[j];
			}
			arr[j + 1] = tmp;
		}
	}
}
void shell_sort(int arr[], int length){
	int step = length / 2;
	while (step>=1){
		for (int k = step; k < length;k++){
			for (int i = 1; i < length;i++){
				if (arr[i] < arr[i-1]){
					int j = 0;
					int tmp = arr[i];
					for (j = i - step; j >= 0 && arr[j] > tmp;j-=step){
						arr[j + step] = arr[j];
					}
					arr[j + step] = tmp;
				}
			}
		}
		step /= 2;
	}
}
#define MAX (623+1)
void radix_sort(int arr[],int length){
	int tmp[MAX] = {0};
	for (int i = 0; i < length;i++){
		tmp[arr[i]]++;
	}
	for (int i = 0; i < MAX;i++){
		while (tmp[i]--){
			printf("%d ",i);
		}
	}
}
#define MAXNUM 623
#define NUM 13
void bucket_sort(int arr[],int length){
	for (int i = 1; i < MAXNUM;i*=10){
		int tmp[10][NUM];
		memset(tmp,-1,sizeof(int)*10*NUM);
		// 根据元素情况入桶
		for (int j = 0; j < length;j++){
			int m = arr[j] / i % 10;
			tmp[m][j] = arr[j];
		}
		// 出桶
		int k = 0;
		for (int i = 0; i < 10;i++){
			for (int j = 0; j < NUM;j++){
				if (-1 != tmp[i][j]){
					arr[k++] = tmp[i][j];
				}
			}
		}
	}
}
void bubble_sort(int arr[],int length){
	for (int i = 0; i < length-1;i++){
		for (int j = 0; j < length - i - 1;j++){
			if (arr[j+1] < arr[j]){
				int tmp = arr[j];
				arr[j] = arr[j+1];
				arr[j + 1] = tmp;
			}
		}
	}
}
int mainq(){
	int arr[] = {87,623,89,23,10,425,78,3,2,20,1,12,2};
	int length = sizeof(arr) / sizeof(arr[0]);
	Print(arr, length);
	bubble_sort(arr, length);
	Print(arr, length);
	system("pause");
	return 0;
}

// 拆半 分治
// 二分查找 归并排序


// 树：各种程序，底层,例如：文件系统（多分支树状结构）
// 森林:多棵树
// 树具备递归性 
// 根：第一个结点 第一颗子树
// 层 ：同层结点到根的距离相等
//路径长度：找到某个结点经过几次寻址
// 高度: 最远叶子结点的距离
// N叉树
// 链表就是一个1叉树
