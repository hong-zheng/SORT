#define _CRT_SRCURE_NO_WARNINGS 1
#include<stdio.h>
#include<stdlib.h>
#include<string.h>



void Print(int arr[],int length){
	for (int i = 0; i < length;i++){
		printf("%d ",arr[i]);
	}
	printf("\n");
}
//    bubble
void insert_sort(int arr[],int length){
	for (int i = 1; i < length;i++){
		if (arr[i] < arr[i-1]){
			int j = 0;
			int tmp = arr[i];
			for (j = i - 1; j >= 0 && arr[j] > tmp;j--){
				arr[j + 1] = arr[j];
			}
			arr[j + 1] = tmp;
		}
	}
}
void shell_sort(int arr[], int length){
	int step = length / 2;
	while (step>=1){
		for (int k = step; k < length;k++){
			for (int i = 1; i < length;i++){
				if (arr[i] < arr[i-1]){
					int j = 0;
					int tmp = arr[i];
					for (j = i - step; j >= 0 && arr[j] > tmp;j-=step){
						arr[j + step] = arr[j];
					}
					arr[j + step] = tmp;
				}
			}
		}
		step /= 2;
	}
}
#define MAX (623+1)
void radix_sort(int arr[],int length){
	int tmp[MAX] = {0};
	for (int i = 0; i < length;i++){
		tmp[arr[i]]++;
	}
	for (int i = 0; i < MAX;i++){
		while (tmp[i]--){
			printf("%d ",i);
		}
	}
}
#define MAXNUM 623
#define NUM 13
void bucket_sort(int arr[],int length){
	for (int i = 1; i < MAXNUM;i*=10){
		int tmp[10][NUM];
		memset(tmp,-1,sizeof(int)*10*NUM);
		// 根据元素情况入桶
		for (int j = 0; j < length;j++){
			int m = arr[j] / i % 10;
			tmp[m][j] = arr[j];
		}
		// 出桶
		int k = 0;
		for (int i = 0; i < 10;i++){
			for (int j = 0; j < NUM;j++){
				if (-1 != tmp[i][j]){
					arr[k++] = tmp[i][j];
				}
			}
		}
	}
}
void bubble_sort(int arr[],int length){
	for (int i = 0; i < length-1;i++){
		for (int j = 0; j < length - i - 1;j++){
			if (arr[j+1] < arr[j]){
				int tmp = arr[j];
				arr[j] = arr[j+1];
				arr[j + 1] = tmp;
			}
		}
	}
}
//[]
//2
int removeElement(int* nums, int numsSize, int val){
	int k = 0;
	for (int i = 0; i<numsSize - k; i++){
		if (val == nums[i]){
			for (int j = i+1; j<numsSize-k; j++){
				nums[j-1] = nums[j];
			}
			i--;
			k++;
		}
	}
	return numsSize-k;
}
//int nums1[] = { 1, 2, 3, 0, 0, 0 };
//int num1 = 3;
//int nums2[] = { 2, 5, 6 };
////int num2 = 3;
//void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
//	while (m>0 && n>0){
//		if (nums1[m - 1] >= nums2[n - 1]){
//			nums1[nums1Size - 1] = nums1[m - 1];
//			nums1Size--;
//			m--;
//		}
//		if (nums1[m - 1] < nums2[n - 1]){
//			nums1[nums1Size - 1] = nums2[n - 1];
//			nums1Size--;
//			n--;
//		}
//	}
//	if (n>0){
//		// memcpy(nums1,nums2,sizeof(int)*nums1Size);
//		for (int i = 0; i<nums1Size; i++){
//			nums1[i] = nums2[i];
//		}
//	}
//}
//[2, 0]
//1
//[1]
//1
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
	int* newnums = (int*)malloc(sizeof(int)*(m + n));
	int i = 0;
	int j = 0;
	int k = 0;
	while (i<m && j<n){
		if (nums1[i] >= nums2[j]){
			newnums[k] = nums2[j];
			k++;
			j++;
		}
		if (nums1[i] < nums2[j]){
			newnums[k] = nums1[i];
			k++;
			i++;
		}
	}
	if (i<m){
		memcpy(newnums + k, nums1 + i, sizeof(int)*(m - i));
	}
	if (j<n){
		memcpy(newnums + k, nums2 + j, sizeof(int)*(n - j));
	}
	memcpy(nums1, newnums, sizeof(int)*(m + n));
	free(newnums);
}
void rotate(int* nums, int numsSize, int k){
	k = k%numsSize;
	for (int i = 0; i<k; i++){
		int bbjj = nums[numsSize - 1];
		for (int j = numsSize - 2; j >= 0; j--){
			nums[j + 1] = nums[j];
		}
		nums[0] = bbjj;
	}
}
int main(){
	int nums2[] = { 1,2,4,5,6,7};
	//int num2 = 6;
	//int nums1[] = { 1,1,2,3,0,0,0,0,0,0};
	//int num1 = 4;
	////merge(nums1, sizeof(nums1) / sizeof(nums1[0]), num1, nums2, sizeof(nums1) / sizeof(nums1[0]), num2);
	//Print(nums1, sizeof(nums1) / sizeof(nums1[0]));

	//int arr[] = { 0, 1, 2, 2, 3, 0, 4, 2 };
	//int length = sizeof(arr) / sizeof(arr[0]);
	//Print(arr, length);
	//rotate(arr,length,9);
	//Print(arr, length);
	int sum = 100133;
	int count = 0;
	for (int i = 1; i<=sum; i *= 10){
		count++;
	}
	printf("%d ",count);
	system("pause");
	return 0;
}

// 拆半 分治
// 二分查找 归并排序


// 树：各种程序，底层,例如：文件系统（多分支树状结构）
// 森林:多棵树
// 树具备递归性 
// 根：第一个结点 第一颗子树
// 层 ：同层结点到根的距离相等
//路径长度：找到某个结点经过几次寻址
// 高度: 最远叶子结点的距离
// N叉树
// 链表就是一个1叉树
